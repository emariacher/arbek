package git2surround
import java.io.FilenameFilter

import java.io.File
import java.text.ParsePosition;
import java.util.Calendar
import java.util.Date
import java.text.SimpleDateFormat
import scala.collection.immutable.ListSet
object TaggedCommit extends Ordering[TaggedCommit] {
	def parseGitDate(s: String): Date = {			formatIn.parse(s, new ParsePosition(0));	};	val formatIn  = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");	val r_date = """Date:(.+)""".r;		def compare (x: TaggedCommit, y: TaggedCommit): Int = {			x.date .compareTo(y.date);	}
}

class TaggedCommit(L: MyLog, l: List[String]) extends Ordering[TaggedCommit] { 	var l_chkin = List.empty[String];	var s_dirSurround_short = "";	var s_dirSurround = "";	var repos = "";	var b_backuped = false;	val r_tagv = """.+tag: (\w+),.*""".r;	val r_tagp = """.+tag: (\w+)\).*""".r;	val r_author = """Author:(.+)""".r;	val r_repos = """Repository: (.+)""".r;	val r_branch = """Branch: (.+)""".r;	var s_tag = "NO TAG";	var s_comment = "--rien--";	var date = new Date();	var s_gitRepos = "NO TAG";	var s_gitBranch = "NO BRANCH";	l.foreach((s: String) => s match {
	case r_tagv(s_tagTmp) => s_tag = s_tagTmp; L.myPrintln("    TAG["+s_tag+"] + BRANCH(ES)");
	case r_tagp(s_tagTmp) => s_tag = s_tagTmp; L.myPrintln("    TAG["+s_tag+"]");	case TaggedCommit.r_date(s_dateTmp) => date = TaggedCommit.parseGitDate(s_dateTmp);	case r_repos(s_reposTmp) => s_gitRepos = s_reposTmp;	case r_branch(s_branchTmp) => s_gitBranch = s_branchTmp;	case r_author(s_authorTmp) => ;	case _ => s_comment = s;
	});

	def this(L: MyLog, l: List[String], a: Int) {
		this(L,List[String]())
		if(l.size==3) {
			s_tag = l(0);
			date = TaggedCommit.formatIn.parse(l(1), new ParsePosition(0));
			s_gitRepos = l(2)
		}
	};
	override def equals(that: Any): Boolean = {
			val that_tg = that.asInstanceOf[TaggedCommit];
			((s_tag==that_tg.s_tag)&&(date==that_tg.date))
	};

	override def toString(): String = {			s_gitRepos + " " + s_gitBranch + " " + s_tag + " " + MyLog.printZisday(date, "ddMMMyy_HH:mm:ss") + " " + s_comment	};	def getCheckoutBranch(L: MyLog, line: Int, i_rci: errorCode, s_tag: String, s_dirgit: String): errorCode = {			var i_rc = i_rci;			L.myErrPrintln("</pre><h4>"+MyLog.tag(2)+"."+MyLog.func(1)+"(" + s_dirgit + " " + s_tag + " "+ MyLog.printZisday(date, "ddMMMyy")+")***</h4><pre>");			if(i_rc == errorCode.OK) {				i_rc = ScalaBatsh.execrcdir(L, i_rc, "git branch",s_dirgit)._1;				var gitStatus = ScalaBatsh.execrcdir(L, i_rc,"git status", s_dirgit);				i_rc = gitStatus._1;				if(gitStatus._2.exists(_.indexOf("# On branch "+s_tag)<0)) {									i_rc = ScalaBatsh.execrcdir(L, i_rc,"git checkout -B br_" + s_gitBranch +"__"+s_tag+" "+s_tag, s_dirgit)._1;					i_rc = ScalaBatsh.execrcdir(L, i_rc, "git branch",s_dirgit)._1;				};			};			i_rc;	}

	def git2Surround(gr: gitBranch) {		val g2s = gr.g2s;		var i_rc = errorCode.OK;		val s_dir_short = s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1) + "_" + s_tag;		val s_label = s_tag + "__" + s_gitBranch + "__" + s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1);		val comment = s_label + "_"+ MyLog.printZisday(date, "ddMMMyy");		s_dirSurround_short = s_label;		val s_dirSurroundRoot = g2s.s_workingDirectory + File.separatorChar + s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1) + "_surround";		s_dirSurround = s_dirSurroundRoot + File.separatorChar + s_label;		val s_dirgit = g2s.s_workingDirectory + File.separatorChar + s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1);		var b_useprevtc = false;		repos = g2s.sscmMainLine+"\\"+s_label;		L.myErrPrintDln("\n\n\n\n</pre><h3>***"+MyLog.func(1)+"("+s_gitRepos + "__" + s_gitBranch + "__" + comment+")***</h3><pre>");		// get list of files to check-in		getCheckoutBranch(L, 117, errorCode.OK, s_tag, s_dirgit);		l_chkin = ScalaBatsh.execrcdir(L,i_rc,"ls -Rm",s_dirgit)._2.filter(_.indexOf(">")<0);					// check that label does not exist in Surround, otherwise that means tag has already been saved		i_rc = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm addlabel "+s_label+" -b"+s_gitRepos+" -p"+g2s.sscmMainLine+				" -d"+s_label+g2s.s_sscmAccess, g2s.s_uid_pwd)._1;		if(i_rc == errorCode.OK) {			// get list of files in previous check-in			val index = gr.ll_taggedCommits.indexOf(this);			if(index>0) {				val prevtc = gr.ll_taggedCommits.apply(index-1);				val l_prevchkin = prevtc.l_chkin;				L.myPrintDln("l_prevchkin: "+l_prevchkin);				L.myPrintDln("l_chkin: "+l_chkin);				if(l_chkin==l_prevchkin) {					s_dirSurround_short = prevtc.s_dirSurround_short;					s_dirSurround = prevtc.s_dirSurround;					repos = prevtc.repos;					b_useprevtc = true;				}			};			// build surround stuff			i_rc = ScalaBatsh.createDirectory(L,s_dirSurroundRoot,s_dirSurround_short);			if(!b_useprevtc) {				i_rc = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm mkrepository "+s_label+" -b"+s_gitRepos+" -p"+g2s.sscmMainLine+" -cc"+comment+						g2s.s_sscmAccess, g2s.s_uid_pwd)._1;			};			i_rc = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm workdir "+s_dirSurround+" "+repos+" -b"+s_gitRepos+" -r -o"+					g2s.s_sscmAccess, g2s.s_uid_pwd)._1;			i_rc = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm workdirinfo "+s_dirSurround+" -r", g2s.s_uid_pwd)._1;						if(b_useprevtc) {				i_rc = ScalaBatsh.execrcNoPwdDir(L,i_rc,"sscm checkout * -b"+s_gitRepos+" -p"+repos+" -r -f -wreplace -cc"+comment+" "+						g2s.s_sscmAccess, g2s.s_uid_pwd,s_dirSurround)._1;				};			i_rc = ScalaBatsh.cleanDirectory(L, s_dirSurroundRoot, s_dirSurround_short);			// copy dir			i_rc = ScalaBatsh.execrc(L,i_rc,"cp -r "+s_dirgit+" "+s_dirSurround)._1;			// remove git info			i_rc = ScalaBatsh.execrcdir(L,i_rc,"rm -rf .git",s_dirSurround)._1;			if(b_useprevtc) {				// checkin files				i_rc = ScalaBatsh.execrcNoPwdDir(L,i_rc,"sscm checkin * -l"+s_label+" -b"+s_gitRepos+" -p"+repos+" -r -cc"+comment+						g2s.s_sscmAccess, g2s.s_uid_pwd, s_dirSurround)._1;			} else {				// add files				i_rc = ScalaBatsh.execrcNoPwdDir(L,i_rc,"sscm add * -l"+s_label+" -b"+s_gitRepos+" -p"+repos+" -r -cc"+comment+						g2s.s_sscmAccess, g2s.s_uid_pwd, s_dirSurround)._1;			}		} else {			i_rc=errorCode.OK;		};		val b_alreadyBranched = g2s.l_lsbranch.exists((s: String) => s.indexOf(s_label)>=0);		if(!b_alreadyBranched) {			i_rc = ScalaBatsh.execrcNoPwdDir(L,i_rc,"sscm mkbranch "+s_label+" "+repos+" -b"+s_gitRepos+" -l"+s_label+" -ssnapshot -cc"+comment+					g2s.s_sscmAccess, g2s.s_uid_pwd, s_dirSurround)._1;		} else {			i_rc = errorCode.alreadyBackUped;		};		if(i_rc==errorCode.OK) {			b_backuped = true;			L.myErrPrintDln("<b><font color=\"red\">*2***Surround Back-up Done for: "+comment+"</font></b>");		};		L.myErrPrintln("  "+MyLog.tag(1)+" "+s_dir_short+", rc: {"+errorCode.nameOf(i_rc)+"}\n---------------------------\n\n");	};	def compare (x: TaggedCommit, y: TaggedCommit): Int = {			x.date .compareTo(y.date);	};	def - (tc: TaggedCommit) = ((date.getTime - tc.date.getTime) / (1000*3600*24)).toInt;	def lastCommit(d: Date) = ((d.getTime - date.getTime) / (1000*3600*24)).toInt;};