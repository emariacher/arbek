package git2surround;import java.io.File;import java.util.Date;import scala.collection.immutable.ListSet;object GitRepository {	def buildSurroundBaseline(L: MyLog, g2s: Git2Surround, s_gitRepos: String): errorCode = {			L.myErrPrintln(this.getClass.getName+" buildSurroundBaseline("+s_gitRepos+")");			val r_branch = """(\w+) \(branch\).*""".r;			var i_rc =errorCode.OK;			val b_alreadyBranched = g2s.l_lsbranch.exists((s: String) => s.indexOf(s_gitRepos+" (baseline)")>=0);			if(!b_alreadyBranched) {				i_rc = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm mkbranch "+s_gitRepos+" "+g2s.sscmMainLine+" -sbaseline -c-"+g2s.s_sscmAccess, g2s.s_uid_pwd)._1;			};			i_rc	};	};class GitRepository(val g2s: Git2Surround, val s_gitRepos: String) {	val L = g2s.L;	var i_rc = errorCode.OK;	var i_backupedTag = 0;	var l_remoteBranches = List.empty[String];	var l_gitBranches = List.empty[gitBranch];	L.myPrintln("************************************************************************************************"); 	L.myErrPrintln("</pre><h2>***"+this.getClass.getName+"("+s_gitRepos+")****************************************</h2><pre>"); 	L.myPrintln("************************************************************************************************"); 	val s_dir = g2s.s_workingDirectory + File.separatorChar + s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1);	// clean directory	i_rc = ScalaBatsh.cleanDirectory(L,28,g2s.s_workingDirectory,s_gitRepos.substring(s_gitRepos.lastIndexOf("/")+1));	// double check that directory exists	i_rc = ScalaBatsh.execrcdir(L, 38, i_rc, "echo double check that ["+g2s.s_workingDirectory+"] directory exists",g2s.s_workingDirectory)._1;	// clone repository	i_rc = ScalaBatsh.execrcdir(L, 41, i_rc, "git clone "+g2s.s_gitServer+":"+s_gitRepos+"\nls -altr",g2s.s_workingDirectory)._1;	// double check that directory exists	i_rc = ScalaBatsh.execrcdir(L, 44, i_rc, "echo double check that ["+s_dir+"] directory exists",s_dir)._1;		// list remote branches	val gitremoteBranches = ScalaBatsh.execrcdir(L,45,i_rc,"\ngit branch -r",s_dir);	i_rc = gitremoteBranches._1;	if(i_rc == errorCode.OK) {		l_remoteBranches = gitremoteBranches._2.filter(_.indexOf("  origin")==0).tail.map{_.substring(9)};		L.myErrPrintln(this.getClass.getName+l_remoteBranches.mkString("</pre>remote branches:<ul>\n  <li>","</li>\n  <li>","</li></ul><pre>"));		val gitbranch = ScalaBatsh.execrcdir(L, 36, i_rc, "git branch",s_dir);		i_rc = gitbranch._1;		L.myErrPrintln(this.getClass.getName+gitbranch._2.mkString("</pre>current branch:<ul>\n  <li>","</li>\n  <li>","</li></ul><pre>"));	};	l_gitBranches = l_remoteBranches.map{new gitBranch(this, _)};	L.myErrPrintln(this.getClass.getName+l_gitBranches.mkString("</pre>"+s_gitRepos+" branches:<ul>\n  <li>","</li>\n  <li>","</li></ul><pre>"));		// check for checkout files meaning we have an issue	val l_ls = ScalaBatsh.execrcNoPwd(L,i_rc,"sscm ls / -b"+s_gitRepos+" -p"+g2s.sscmMainLine+" -r "+g2s.s_sscmAccess, g2s.s_uid_pwd);	Git2Surround.checkException(L,l_ls._1,"1 check for checkout files meaning we have an issue");	if(l_ls._2.exists((s: String) => s.indexOf("-checked out")>=0)) {	  Git2Surround.checkException(L,errorCode.checkedOutFiles,"2 check for checkout files meaning we have an issue for ["+s_gitRepos+"");	};	L.myErrPrintln("  "+this.getClass.getName+" "+s_gitRepos+", rc="+i_rc+" {"+errorCode.nameOf(i_rc)+"}");	override def toString(): String = {			l_gitBranches.mkString("<b>"+s_gitRepos+"</b> branches:<ul>\n  <li>","</li>\n  <li>","</li></ul>");	};};