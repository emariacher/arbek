package git2surround
import java.io.File;import org.scalatest.events.Event;
import org.scalatest._;
import org.scalatest.FunSuite
import org.scalatest.matchers.ShouldMatchers;import java.util.concurrent.TimeUnit;import java.util.concurrent.FutureTask;import scala.swing._;

// scala org.scalatest.tools.Runner -p . -o -s git2surround.Git2SurroundTest1// scala org.scalatest.tools.Runner -p . -o -s git2surround.Git2SurroundTest// scala org.scalatest.tools.Runner -p . -o -s git2surround.ScalaBatshTest// scala org.scalatest.tools.Runner -p . -o -s git2surround.GitOsisTest// scala org.scalatest.tools.Runner -p . -o -s git2surround.SurroundPartTest// scala org.scalatest.tools.Runner -p . -o -s git2surround.deleteBranches// scala org.scalatest.tools.Runner -p . -o -s git2surround.scalabean// scala org.scalatest.tools.Runner -p . -o -s git2surround.swing// scala org.scalatest.tools.Runner -p . -o -s git2surround.filechooserclass filechooser extends FunSuite with ShouldMatchers {	val rc = errorCode.baselineNotFound;	println(rc);	val f = (new MyFileChooser("gnagnaco")).justChooseFile("xml");	val L = new MyLog(this.getClass.getName,f,"htm");	L.myErrPrintln("Tcho!");	L.closeFiles();	rc should equal (errorCode.OK);};class swing extends FunSuite with ShouldMatchers {	val rc = errorCode.baselineNotFound;	println(errorCode.nameOf(rc));	val mui = new MyUI("getAndClose", List(("uid","emariacher",new TextField),("pwd","",new PasswordField)));	println(mui.getAndClose.mkString("1    i  ","\n1    i  ","\n"));	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog("MyLog and get",s_file,"htm");	L.createGui(List(("uid","emariacher",new TextField),("pwd","",new PasswordField)));	println(L.Gui.get.mkString("2    i  ","\n2    i  ","\n"));		val theTask2 = new FutureTask(new Runnable() {		def run() {			var i=0;			while(true){L.myErrPrint(""+i); i+=1;};		};	}, null);	new Thread(theTask2).start();	theTask2.get(5000, TimeUnit.MILLISECONDS);	L.closeFiles;	rc should equal (errorCode.OK);};class scalabean extends FunSuite with ShouldMatchers {	val rc = errorCode.baselineNotFound;	println(rc);	println(errorCode.values);	println(errorCode.names);	println(errorCode.nameOf(rc));	rc should equal (errorCode.OK);};class Git2SurroundTest1 extends FunSuite with ShouldMatchers {	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog(this.getClass.getName,s_file,"htm");	var l_parameters = List[String]();	scala.io.Source.fromFile(s_file).getLines.foreach((s: String) => l_parameters ++= List(s));	L.myErrPrintln(l_parameters.mkString("l_parameters:\n  ","\n  ",""));	l_parameters.isEmpty should be (false);	val s_myWorkingDirectory = "C:\\SandBox\\zzgit";
	val s_directoryDoesntExist = "cowabunga";
	val s_directoryExistsButDoesntBelongToGit = "C:\\SandBox"

			test("Check bad directories" ) {
		evaluating { new Git2Surround(L, List[String]()) } should produce [java.lang.IndexOutOfBoundsException];
		evaluating { new Git2Surround(L, List("",s_directoryDoesntExist)) } should produce [java.lang.Exception];
		evaluating { new Git2Surround(L, List("",s_directoryDoesntExist,"")) } should produce [java.lang.Exception]
	}	
	test("Check Not a git repository" ) {
		evaluating { new Git2Surround(L, List("",s_directoryExistsButDoesntBelongToGit,"a","b:c")) } should produce [java.lang.Exception]
	} 
	test("bad server name" ) {
		val g2s = new Git2Surround(L, List("zorglub",s_myWorkingDirectory,"a","b:c"))
		g2s.i_rc should equal (errorCode.notGitRepository)
		g2s.l_gitRepositories.size should equal (0)
	}	};class Git2SurroundTest extends FunSuite with ShouldMatchers {	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog(this.getClass.getName,s_file,"htm");	var l_parameters = List[String]();	scala.io.Source.fromFile(s_file).getLines.foreach((s: String) => l_parameters ++= List(s));	L.myPrintln(l_parameters.mkString("l_parameters:\n  ","\n  ",""));	l_parameters.isEmpty should be (false);	val s_myWorkingDirectory = "C:\\SandBox\\zzgit";	test("Get tagged commits list" ) {		val g2s = new Git2Surround(L, l_parameters);		g2s.i_rc should equal (errorCode.OK)	};};class deleteBranches extends FunSuite with ShouldMatchers {	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog(this.getClass.getName,s_file,"html");	var l_parameters = List[String]();	scala.io.Source.fromFile(s_file).getLines.foreach((s: String) => l_parameters ++= List(s));	L.myPrintln(l_parameters.mkString("l_parameters:\n  ","\n  ",""));	l_parameters.isEmpty should be (false);	val s_myWorkingDirectory = "C:\\SandBox\\zzgit";	val l_args = l_parameters;	val s_gitServer = l_args(0);	val s_workingDirectory = l_args(1);	val s_SCMAdd = l_args(2);	val l_uid_pwd = l_args(3).split(':').toList;	val s_uid_pwd = l_uid_pwd(0) + ":"+ List.fromString(l_uid_pwd(1),' ').reverse.mkString("","","");	val s_sscmAccess = " -y"+s_uid_pwd+" -z"+s_SCMAdd;	val sscmMainLine = l_args(4);	val i_period2scan = l_args(5).toInt;	test("deleteBranches" ) {		val l_lsbranch = ScalaBatsh.execrcNoPwd(L,errorCode.OK,"sscm lsbranch -p"+sscmMainLine+" -a"+s_sscmAccess, s_uid_pwd);		var i_rc = l_lsbranch._1;		val l_snapshots = l_lsbranch._2.filter((s: String) => s.indexOf("(snapshot)")>=0).map {(s: String) => s.substring(0,s.indexOf(" "))};		L.myPrintln(l_snapshots.mkString("l_snapshots:\n  ","\n  ",""));		l_snapshots.foreach((s: String) => ScalaBatsh.execrcNoPwd(L,i_rc,"sscm rmlabel "+s+" -p"+sscmMainLine+				s_sscmAccess, s_uid_pwd));		l_snapshots.foreach((s: String) => ScalaBatsh.execrcNoPwd(L,i_rc,"sscm rmbranch "+s+" -p"+sscmMainLine+" -d -c-"+				s_sscmAccess, s_uid_pwd));		i_rc should equal (errorCode.OK);	}};class myReporter(val L: MyLog, val s_suiteName: String) extends org.scalatest.Reporter {
	var i_testFailed = 0;
	var i_testRunned = 0
			override def apply(event: Event): Unit = {
			event match {
			case e: org.scalatest.events.TestStarting => L.myPrintln("[32m*****TestStarting*******"+ e.testName+"][0m"); i_testRunned +=1
			case e: org.scalatest.events.TestSucceeded => L.myErrPrintln("[32m*****TestSucceeded*******"+ e.testName+"][0m")
			case e: org.scalatest.events.TestFailed => L.myErrPrintln("[31m*****TestFailed*******"+ e.testName +"["+ e.message+"][0m");
			i_testFailed +=1; 
			//			org.scalatest.events.TestFailed(e.ordinal, e.testName, e.message, Some(s_suiteName), s_suiteName, e.throwable);
			throw new TestFailedException(1)
			case e: org.scalatest.events.InfoProvided => L.myPrintln("[33m*****InfoProvided*******"+ e.message+"][0m")
			case e => L.myPrintln("*****SomethingElse*******"+ e)
			}
	}
};class ScalaBatshTest extends FunSuite with ShouldMatchers {	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog(this.getClass.getName,s_file,"html");	val s_directoryDoesExist = "C:\\SandBox\\emariacher";	val s_directoryDoesntExist = "cowabunga";	test("Check cd directory" ) {		ScalaBatsh.exec(L,"cd "+s_directoryDoesExist)._1 should equal (errorCode.OK);		ScalaBatsh.exec(L,"cd "+s_directoryDoesntExist)._1 should equal (errorCode.noSuchDirectory);		ScalaBatsh.exec(L,"pwd")._1 should equal (errorCode.OK);		ScalaBatsh.exec(L,"pwd")._2.isEmpty should be (false);		ScalaBatsh.exec(L,"pwd")._3.isEmpty should be (true);		ScalaBatsh.exec(L,"echo zubzabzub")._2(2) should equal ("zubzabzub");		ScalaBatsh.execNoPwd(L,"echo zubzabzub","zub")._2(2) should equal ("##hidden##zab##hidden##");		ScalaBatsh.execrcNoPwd(L,errorCode.OK,"echo zubzabzub","zub")._2(2) should equal ("##hidden##zab##hidden##");		ScalaBatsh.execrcNoPwd(L,errorCode.unknownError,"echo zubzabzub","zub")._1 should equal (1);		ScalaBatsh.execrcNoPwd(L,errorCode.unknownError,"echo zubzabzub","zub")._2.isEmpty should be (true);		ScalaBatsh.execrcNoPwd(L,errorCode.unknownError,"echo zubzabzub","zub")._3.isEmpty should be (true);	}	};class GitOsisTest extends FunSuite with ShouldMatchers {	val s_file = new File("..\\out\\placeholder.g2s");	val L = new MyLog(this.getClass.getName,s_file,"test");	var l_parameters = List[String]();	scala.io.Source.fromFile(s_file).getLines.foreach((s: String) => l_parameters ++= List(s));	L.myErrPrintln(l_parameters.mkString("l_parameters:\n  ","\n  ",""));	l_parameters.isEmpty should be (false);	val s_myWorkingDirectory = "C:\\SandBox\\zzgit";	test("Check GitOsis" ) {		val go = new GitOsis(L,s_myWorkingDirectory,"git@turing","gitosis-admin.git");		go.l_groups.isEmpty should be (false)	}	};